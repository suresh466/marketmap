# Rate limiting zone definition
limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;
server {
    listen 80;                 # Listen on port 80 (HTTP)
    root /usr/share/nginx/html; # Base directory for static files (React build output)
    index index.html;          # Default file to serve

    # Logging configuration
    access_log /var/log/nginx/access.log main buffer=16k flush=10s;
    error_log /var/log/nginx/error.log warn;

    # Frontend application routing
    location / {
        try_files $uri $uri/ /index.html; # Enable SPA routing (React router)
        # This tries to:
        # 1. Serve the exact URI requested
        # 2. Then try URI/ as a directory
        # 3. Finally fall back to /index.html (React takes over routing)
    }


    # API request handling
    location /api/ {

        # IMPORTANT: This matches any URL beginning with /api/
        # Example: /api/graph, /api/booths, etc.

        # Nginx Path Processing:
        # - Location block = "what to match in the incoming URL"
        # - If proxy_pass has a path, the matched portion gets REPLACED
        # - If proxy_pass has no path, the full original path is PRESERVED
        proxy_pass http://backend:8000;
        # Without a path after the hostname, Nginx PRESERVES the full original path
        # So /api/graph â†’ http://backend:8000/api/graph
        # This works because our FastAPI routes include /api/ in their paths

        # Apply rate limiting: 10 requests/second with a burst of 20
        limit_req zone=api_limit burst=20 nodelay;
        limit_req_status 429; # Return 429 Too Many Requests instead of default 503

        # Log rate-limited requests separately
        access_log /var/log/nginx/api_access.log main buffer=4k flush=5s;
        error_log /var/log/nginx/api_error.log warn;

        # Headers to properly identify the original client to the backend
        proxy_set_header Host $host;               # Original host requested by client
        proxy_set_header X-Real-IP $remote_addr;   # Client's actual IP
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # Chain of proxies
        proxy_set_header X-Forwarded-Proto $scheme; # Original protocol (http/https)

        # Timeout settings
        proxy_connect_timeout 5s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}

# EXAMPLE 1: Redundant Path Replacement
# location /docs/ {
#     proxy_pass http://backend:8000/docs/;
#     # EXPLANATION: This replacement is redundant because:
#     # 1. Request: /docs/index.html
#     # 2. Matched portion: /docs/
#     # 3. Replace with: /docs/
#     # 4. Result: http://backend:8000/docs/index.html
#     # The URL is unchanged - we're replacing /docs/ with /docs/
# }

# EXAMPLE 2: Useful Path Replacement
# location /api/v1/ {
#     proxy_pass http://backend:8000/api/v2/;
#     # EXPLANATION: This demonstrates API versioning:
#     # 1. Request: /api/v1/users
#     # 2. Matched portion: /api/v1/
#     # 3. Replace with: /api/v2/
#     # 4. Result: http://backend:8000/api/v2/users
#     # This lets you expose v1 API to clients while using v2 internally
# }

# EXAMPLE 3: Path Stripping
# location /public-api/ {
#     proxy_pass http://backend:8000/;
#     # EXPLANATION: This removes a prefix:
#     # 1. Request: /public-api/users
#     # 2. Matched portion: /public-api/
#     # 3. Replace with: /
#     # 4. Result: http://backend:8000/users
#     # This lets you add a prefix for external users that isn't needed internally
# }
